# auto-generated by grc.converter

id: FDC_FrequencyDomainChannelizer
label: Frequency Domain Channelizer
category: '[FDC]'

parameters:
-   id: type
    label: Input Type
    category: General
    dtype: enum
    options: ['0', '1']
    option_labels: [Complex, Float]
    option_attributes:
        size: [gr.sizeof_gr_complex, gr.sizeof_float]
        tp: [complex, float]
    hide: part
-   id: blocksize
    label: Blocklen
    category: General
    dtype: int
    default: 2**12
    hide: none
-   id: inpveclen
    label: Input Vector length
    category: General
    dtype: int
    default: '1'
    hide: none
-   id: relinvovl
    label: Relative inverse overlap
    category: General
    dtype: int
    default: '4'
-   id: threaded
    label: Threaded
    dtype: enum
    options: ['1', '0']
    option_labels: ['Yes', 'No']
-   id: freqmode
    label: Frequency mode
    category: General
    dtype: enum
    options: ['0', '1', '2']
    option_labels: [Normalized baseband, Baseband + sample rate, Centerfreq + sample
            rate]
-   id: fs
    label: Samprate
    category: General
    dtype: float
    default: samp_rate
-   id: centerfrequency
    label: Base frequency
    category: General
    dtype: float
    default: 3e6
-   id: debug
    label: Debug Output
    category: General
    dtype: enum
    options: ['1', '0']
    option_labels: ['Yes', 'No']
    option_attributes:
        hide: ['0', '1']
-   id: msgoutput
    label: Message Output
    category: General
    dtype: enum
    options: ['1', '0']
    option_labels: ['Yes', 'No']
-   id: fileoutput
    label: File Output
    category: General
    dtype: enum
    options: ['1', '0']
    option_labels: ['Yes', 'No']
-   id: outputpath
    label: Output path
    category: General
    dtype: string
    default: /home/user/...
-   id: verbose
    label: Log/verbose destination
    dtype: enum
    options: ['0', '1', '2']
    option_labels: [None, Print to console, Log to file]
-   id: windowtype
    label: Window
    category: Throughput
    dtype: enum
    options: ['0', '1', '2']
    option_labels: [Rectangular, HANN, Ramp]
-   id: throughput_channels
    label: Channels
    category: Throughput
    dtype: raw
    default: '[ [0.2, 0.05], [0.4,0.05], [0.6,0.05] ]'
    hide: part
-   id: activity_controlled_channels
    label: Channels
    category: FixedCarrier
    dtype: raw
    default: '[ [0.2, 0.05], [0.4,0.05], [0.6,0.05] ]'
-   id: act_contr_threshold
    label: Power Threshold[dB]
    category: FixedCarrier
    dtype: float
    default: '6'
-   id: pow_act_deactivation_delay
    label: Deactivation delay
    category: FixedCarrier
    dtype: int
    default: '1'
-   id: pow_act_maxblocks
    label: Max active blocks
    category: FixedCarrier
    dtype: int
    default: '128'
-   id: activity_detection_segments
    label: Segments
    category: Detection
    dtype: raw
    default: '[ [0.1, 0.2], [0.7, 0.9], ]'
-   id: act_det_threshold
    label: Power Threshold[dB]
    category: Detection
    dtype: float
    default: '10'
-   id: minchandist
    label: Minimum channel distance
    category: Detection
    dtype: float
    default: '0.005'
-   id: minchanflankpuffer
    label: Min channel flank puffer
    category: Detection
    dtype: float
    default: '0.2'
-   id: act_det_deactivation_delay
    label: Deactivation delay
    category: Detection
    dtype: int
    default: '1'
-   id: act_det_maxblocks
    label: Max active blocks
    category: Detection
    dtype: int
    default: '128'

inputs:
-   domain: stream
    dtype: ${ type.tp }
    vlen: ${ inpveclen }

outputs:
-   label: debug
    domain: stream
    dtype: complex
    vlen: ${ blocksize }
    optional: true
    hide: ${ debug.hide }
-   label: throughput_out
    domain: stream
    dtype: complex
    multiplicity: ${ len(throughput_channels) }
    optional: true
-   domain: message
    id: msgout
    optional: true

templates:
    imports: import gnuradio.FDC as FDC
    make: FDC.FrequencyDomainChannelizer(${type.size}, ${inpveclen}, ${blocksize},
        ${relinvovl}, ${throughput_channels}, ${activity_controlled_channels}, ${act_contr_threshold},
        ${fs}, ${centerfrequency}, ${freqmode}, ${windowtype}, ${msgoutput}, ${fileoutput},
        ${outputpath}, ${threaded}, ${activity_detection_segments}, ${act_det_threshold},
        ${minchandist}, ${act_det_deactivation_delay}, ${minchanflankpuffer}, ${verbose},
        ${pow_act_deactivation_delay}, ${pow_act_maxblocks}, ${act_det_maxblocks},
        ${debug})

documentation: "##PowerActivationChannelizer##\n\nAuthor and Copyright holder: Gereon\
    \ Such, gereonsuch@gmail.com\n\nThis is a hier block implementing a complete channelizer\
    \ system for frequency/time domain/demand assigned multiple access multicarrier\
    \ systems\n\nThis block implements blockwise overlapping, frequency transofmration\
    \ and three different channelization methods to suite to different applications\n\
    \n#General information#\n\n * IO Type is the input type, choose complex or float\
    \ accordingly. \n * Input Vector Length determines, if the input is already FFT'ed\
    \ or if this should be skipped, for example if you want to calculate the overlapped\
    \ FFT external on an FPGA etc. \n \n * Input is a complex or float stream\n *\
    \ Output is message or file based or streams for constant output channels without\
    \ carrier detection\n \n * Blocklen is the used vector length. It must be a power\
    \ of 2 or will be adjusted accordingly. Small block lengths may lead to insufficient\
    \ carrier detection due to high noise impact, great block lengths may lead to\
    \ malfunctioning burst detection if blocklength exceeds the number of samples\
    \ between bursts\n * Rel. inverse Overlap is the inverse of the used overlap in\
    \ the input vector. It must be a power of 2, typically 4 is chosen, but not necessarily.\
    \ \n * Threaded determines if subblocks should thread themselves. I don't see\
    \ why this should be disabled at all but feel free to do so. \n * Frequency mode\
    \ determines how input frequencies to this block are interpreted.\n    * Normalized\
    \ baseband accepts frequencies in range [0.0:1.0], according to samprate\n   \
    \ * Baseband + sample rate interprets inputs from [0.0:samp_rate]. Carrierfrequency\
    \ is interpreted as 0\n    * Centerfreq + sample rate interprets frequencies as\
    \ the absolute frequency it was received at. \n * Samprate is the sample rate.\
    \ For Normalized baseband frequency mode, it is not used. \n * Basefrequency determines\
    \ the (hardware) carrierfrequency. It is only used in Centerfreq + sample frequency\
    \ mode. \n \n * Message output determines if the channel data should be emitted\
    \ via Gnuradio message passing\n * File output determines if the channel data\
    \ should be emitted as a file\n * Outputfiles is the path to store the channel\
    \ data if File output is true\n * Log/verbose destination specifies if and how\
    \ the activity should be logged.\n    * None means no logging at all, choose this\
    \ for maximum runtime efficiency. \n    * Print to console prints all gathered\
    \ information to console. with many concurrent channelizers, this might mean a\
    \ lot of messages.\n    * Log to file logs the complete output to a file in your\
    \ home dir or from whereever you instantiated the top_block\n \n\n#Throughput\
    \ channelizer#\n\nFor each specified channel in this channelizer, a constant stream\
    \ output is created. \n\nIf no throughput channelizer is used, a stream output\
    \ is displayed in GRC, but without any \"harm\". In this case, you don't need\
    \ to connect it. (nports option of GRC seems to ignore the 0)\n\n * Window specifies\
    \ the used window. HANN window should suffice in most cases. \n * Channels accepts\
    \ a list of 2 element-lists of floats, where the first element is the mid frequency\
    \ according to frequency mode, the second element is the output minimum bandwidth.\
    \ The actual output bandwidth is always greater than the desired bandwidth, since\
    \ it needs to be a power of 2 according to blocklen. \n   An example is [ [midfreq1,\
    \ chanbw1], [midfreq2, chanbw2], ... ]\n\n\n#Fixed Carrier power activation#\n\
    \nFor each specified channel a channelizer with power detection is implemented.\
    \ It activates and deactivates according to input power and emits the received\
    \ data according to output modes. \n\n * Channels accepts a list of 2 element-lists\
    \ of floats, where the first element is the mid frequency according to frequency\
    \ mode, the second element is the output minimum bandwidth. The actual output\
    \ bandwidth is always greater than the desired bandwidth, since it needs to be\
    \ a power of 2 according to blocklen. \n   An example is [ [midfreq1, chanbw1],\
    \ [midfreq2, chanbw2], ... ]\n * Power Threshold[dB] is the minimum power difference\
    \ in dB in consecutive blocks to activate and deactivate the channel. \n * Deactivation\
    \ delay is currently not implemented. Feel free to enter whatever you like ;)\n\
    \ * Max active blocks smaller 0 leads to only emit messages if the channel end\
    \ is detected. Equal 0, every block is emitted, greater 0, the according size\
    \ of blocks is determined as a maximum puffered blocknumber and the data to that\
    \ point is emitted with according flags.   \n \n\n#Detection mode#\n\nFor each\
    \ specified segment a channelizer with power detection is implemented. In the\
    \ specified range, it detects carriers, adjusts the extraction bandwidth and emits\
    \ them on closure. \n\n * Segments accepts a list of 2 element-lists of floats,\
    \ where the first element is the startingand the second element is the stop frequency\
    \ according to frequency mode. In this range, the carriers are detected accordingly.\
    \ \n   An example is [ [seg1start, seg1stop], [seg2start, seg2stop], ... ]\n *\
    \ Power Threshold[dB] is the power of an edge of a carrier that needs to be exceeded\
    \ to be recognized. Choose this carefully as it might lead to failed carrier recognition.\
    \ \n * Minimum channel distance leads to a factor for averaging of the power in\
    \ the segment to reduce complexity in carrier detection and reduce noise peaks.\
    \ \n * Min channel flank puffer is the one sided puffer relative to the detected\
    \ bandwidth of a signal that is added to avoid filter flanks in signal edges.\n\
    \ \n * Deactivation delay is the number of consecutive blocks without activity\
    \ it takes to turn off a channel\n * Max active blocks smaller 0 leads to only\
    \ emit messages if the channel end is detected. Equal 0, every block is emitted,\
    \ greater 0, the according size of blocks is determined as a maximum puffered\
    \ blocknumber and the data to that point is emitted with according flags.   \n\
    \ \nIf you have any trouble, let me know or feel free to contribute @ github.com/gereonsuch/gr-FDC"

file_format: 1
